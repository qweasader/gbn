# Copyright (C) 2021 Greenbone Networks GmbH
# Some text descriptions might be excerpted from (a) referenced
# source(s), and are Copyright (C) by the respective right holder(s).
#
# SPDX-License-Identifier: GPL-2.0-or-later
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

if(description)
{
  script_oid("1.3.6.1.4.1.25623.1.0.117840");
  script_version("2023-02-17T10:19:33+0000");
  script_cve_id("CVE-2002-20001", "CVE-2022-40735");
  script_tag(name:"last_modification", value:"2023-02-17 10:19:33 +0000 (Fri, 17 Feb 2023)");
  script_tag(name:"creation_date", value:"2021-12-16 10:47:19 +0000 (Thu, 16 Dec 2021)");
  script_tag(name:"cvss_base", value:"5.0");
  script_tag(name:"cvss_base_vector", value:"AV:N/AC:L/Au:N/C:N/I:N/A:P");
  script_tag(name:"severity_vector", value:"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H");
  script_tag(name:"severity_origin", value:"NVD");
  script_tag(name:"severity_date", value:"2021-11-16 15:36:00 +0000 (Tue, 16 Nov 2021)");
  script_name("Diffie-Hellman Ephemeral Key Exchange DoS Vulnerability (SSL/TLS, D(HE)ater)");
  script_copyright("Copyright (C) 2021 Greenbone Networks GmbH");
  script_category(ACT_GATHER_INFO);
  script_family("Denial of Service");
  script_dependencies("secpod_ssl_ciphers.nasl");
  script_mandatory_keys("secpod_ssl_ciphers/supported_ciphers", "ssl_tls/port");

  script_xref(name:"URL", value:"https://www.researchgate.net/profile/Anton-Stiglic-2/publication/2401745_Security_Issues_in_the_Diffie-Hellman_Key_Agreement_Protocol");
  script_xref(name:"URL", value:"https://github.com/Balasys/dheater");

  script_tag(name:"summary", value:"The remote SSL/TLS server is supporting Diffie-Hellman ephemeral
  (DHE) Key Exchange algorithms and thus could be prone to a denial of service (DoS)
  vulnerability.");

  script_tag(name:"vuldetect", value:"Checks the supported cipher suites of the remote SSL/TLS
  server.");

  script_tag(name:"insight", value:"- CVE-2002-20001: The Diffie-Hellman Key Agreement Protocol
  allows remote attackers (from the client side) to send arbitrary numbers that are actually not
  public keys, and trigger expensive server-side DHE modular-exponentiation calculations, aka a
  D(HE)ater attack. The client needs very little CPU resources and network bandwidth. The attack may
  be more disruptive in cases where a client can require a server to select its largest supported
  key size. The basic attack scenario is that the client must claim that it can only communicate
  with DHE, and the server must be configured to allow DHE.

  - CVE-2022-40735: The Diffie-Hellman Key Agreement Protocol allows use of long exponents that
  arguably make certain calculations unnecessarily expensive, because the 1996 van Oorschot and
  Wiener paper found that '(appropriately) short exponents' can be used when there are adequate
  subgroup constraints, and these short exponents can lead to less expensive calculations than for
  long exponents. This issue is different from CVE-2002-20001 because it is based on an observation
  about exponent size, rather than an observation about numbers that are not public keys. The
  specific situations in which calculation expense would constitute a server-side vulnerability
  depend on the protocol (e.g., TLS, SSH, or IKE) and the DHE implementation details. In general,
  there might be an availability concern because of server-side resource consumption from DHE
  modular-exponentiation calculations. Finally, it is possible for an attacker to exploit this
  vulnerability and CVE-2002-20001 together.");

  script_tag(name:"impact", value:"This vulnerability allows remote attackers (from the client side)
  to send arbitrary numbers that are actually not public keys, and trigger expensive server-side DHE
  modular-exponentiation calculations, also known as a D(HE)ater attack.

  There could be an increase in CPU usage in the affected component. For OpenSSH, users may observe
  issues such as a slowdown in SSH connections.");

  script_tag(name:"solution", value:"- DHE key exchange should be disabled if no other mitigation
  mechanism can be used and either elliptic-curve variant of Diffie-Hellman (ECDHE) or RSA key
  exchange is supported by the clients. The fact that RSA key exchange is not forward secret should
  be considered.

  - Limit the maximum number of concurrent connections in e.g. the configuration of the remote
  server. For Postfix this limit can be configured via 'smtpd_client_new_tls_session_rate_limit'
  option, for other products please refer to the manual of the product in question on configuration
  possibilities.");

  script_tag(name:"qod_type", value:"remote_banner_unreliable");
  script_tag(name:"solution_type", value:"Mitigation");

  exit(0);
}

include("ssl_funcs.inc");

cipherText = "'DHE' cipher suites";

if( ! port = tls_ssl_get_port() )
  exit( 0 );

if( ! sup_ssl = get_kb_item( "tls/supported/" + port ) )
  exit( 0 );

if( "SSLv3" >< sup_ssl ) {
  sslv3CipherList = get_kb_list( "secpod_ssl_ciphers/sslv3/" + port + "/supported_ciphers" );

  if( ! isnull( sslv3CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    sslv3CipherList = sort( sslv3CipherList );

    foreach sslv3Cipher( sslv3CipherList ) {
      if( sslv3Cipher =~ "^TLS_DHE_.+" ) {
        sslv3Vuln = TRUE;
        sslv3tmpReport += sslv3Cipher + '\n';
      }
    }

    if( sslv3Vuln ) {
      report += cipherText +' accepted by this service via the SSLv3 protocol:\n\n' + sslv3tmpReport + '\n';
    }
  }
}

if( "TLSv1.0" >< sup_ssl ) {
  tlsv1_0CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_0CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_0CipherList = sort( tlsv1_0CipherList );

    foreach tlsv1_0Cipher( tlsv1_0CipherList ) {
      if( tlsv1_0Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_0Vuln = TRUE;
        tlsv1_0tmpReport += tlsv1_0Cipher + '\n';
      }
    }

    if( tlsv1_0Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.0 protocol:\n\n' + tlsv1_0tmpReport + '\n';
    }
  }
}

if( "TLSv1.1" >< sup_ssl ) {
  tlsv1_1CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1_1/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_1CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_1CipherList = sort( tlsv1_1CipherList );

    foreach tlsv1_1Cipher( tlsv1_1CipherList ) {
      if( tlsv1_1Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_1Vuln = TRUE;
        tlsv1_1tmpReport += tlsv1_1Cipher + '\n';
      }
    }

    if( tlsv1_1Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.1 protocol:\n\n' + tlsv1_1tmpReport + '\n';
    }
  }
}

if( "TLSv1.2" >< sup_ssl ) {
  tlsv1_2CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1_2/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_2CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_2CipherList = sort( tlsv1_2CipherList );

    foreach tlsv1_2Cipher( tlsv1_2CipherList ) {
      if( tlsv1_2Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_2Vuln = TRUE;
        tlsv1_2tmpReport += tlsv1_2Cipher + '\n';
      }
    }

    if( tlsv1_2Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.2 protocol:\n\n' + tlsv1_2tmpReport + '\n';
    }
  }
}

if( "TLSv1.3" >< sup_ssl ) {
  tlsv1_3CipherList = get_kb_list( "secpod_ssl_ciphers/tlsv1_3/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_3CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_3CipherList = sort( tlsv1_3CipherList );

    foreach tlsv1_3Cipher( tlsv1_3CipherList ) {
      if( tlsv1_3Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_3Vuln = TRUE;
        tlsv1_3tmpReport += tlsv1_3Cipher + '\n';
      }
    }

    if( tlsv1_3Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.3 protocol:\n\n' + tlsv1_3tmpReport + '\n';
    }
  }
}

if( report ) {
  security_message( port:port, data:report );
  exit( 0 );
}

exit( 99 );
