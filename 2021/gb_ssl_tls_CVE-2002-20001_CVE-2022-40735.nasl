# SPDX-FileCopyrightText: 2021 Greenbone AG
# Some text descriptions might be excerpted from (a) referenced
# source(s), and are Copyright (C) by the respective right holder(s).
#
# SPDX-License-Identifier: GPL-2.0-only

if(description)
{
  script_oid("1.3.6.1.4.1.25623.1.0.117840");
  script_version("2024-10-03T05:05:33+0000");
  script_cve_id("CVE-2002-20001", "CVE-2022-40735", "CVE-2024-41996");
  script_tag(name:"last_modification", value:"2024-10-03 05:05:33 +0000 (Thu, 03 Oct 2024)");
  script_tag(name:"creation_date", value:"2021-12-16 10:47:19 +0000 (Thu, 16 Dec 2021)");
  script_tag(name:"cvss_base", value:"5.0");
  script_tag(name:"cvss_base_vector", value:"AV:N/AC:L/Au:N/C:N/I:N/A:P");
  script_tag(name:"severity_vector", value:"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H");
  script_tag(name:"severity_origin", value:"NVD");
  script_tag(name:"severity_date", value:"2021-11-16 15:36:00 +0000 (Tue, 16 Nov 2021)");
  script_name("Diffie-Hellman Ephemeral Key Exchange DoS Vulnerability (SSL/TLS, D(HE)ater)");
  script_copyright("Copyright (C) 2021 Greenbone AG");
  script_category(ACT_GATHER_INFO);
  script_family("SSL and TLS");
  script_dependencies("gb_ssl_tls_ciphers_gathering.nasl");
  script_mandatory_keys("ssl_tls/ciphers/supported_ciphers", "ssl_tls/port");

  script_xref(name:"URL", value:"https://dheatattack.gitlab.io/");
  script_xref(name:"URL", value:"https://dheatattack.gitlab.io/details/");
  script_xref(name:"URL", value:"https://www.researchgate.net/profile/Anton-Stiglic-2/publication/2401745_Security_Issues_in_the_Diffie-Hellman_Key_Agreement_Protocol");
  script_xref(name:"URL", value:"https://github.com/Balasys/dheater");
  script_xref(name:"URL", value:"https://github.com/c0r0n3r/dheater");

  script_tag(name:"summary", value:"The remote SSL/TLS server is supporting Diffie-Hellman ephemeral
  (DHE) Key Exchange algorithms and thus could be prone to a denial of service (DoS)
  vulnerability.");

  script_tag(name:"vuldetect", value:"Checks the supported cipher suites of the remote SSL/TLS
  server.");

  script_tag(name:"insight", value:"- CVE-2002-20001: The Diffie-Hellman Key Agreement Protocol
  allows remote attackers (from the client side) to send arbitrary numbers that are actually not
  public keys, and trigger expensive server-side DHE modular-exponentiation calculations, aka a
  D(HE)ater attack. The client needs very little CPU resources and network bandwidth. The attack may
  be more disruptive in cases where a client can require a server to select its largest supported
  key size. The basic attack scenario is that the client must claim that it can only communicate
  with DHE, and the server must be configured to allow DHE.

  - CVE-2022-40735: The Diffie-Hellman Key Agreement Protocol allows use of long exponents that
  arguably make certain calculations unnecessarily expensive, because the 1996 van Oorschot and
  Wiener paper found that '(appropriately) short exponents' can be used when there are adequate
  subgroup constraints, and these short exponents can lead to less expensive calculations than for
  long exponents. This issue is different from CVE-2002-20001 because it is based on an observation
  about exponent size, rather than an observation about numbers that are not public keys. The
  specific situations in which calculation expense would constitute a server-side vulnerability
  depend on the protocol (e.g., TLS, SSH, or IKE) and the DHE implementation details. In general,
  there might be an availability concern because of server-side resource consumption from DHE
  modular-exponentiation calculations. Finally, it is possible for an attacker to exploit this
  vulnerability and CVE-2002-20001 together.

  - CVE-2024-41996: Validating the order of the public keys in the Diffie-Hellman Key Agreement
  Protocol, when an approved safe prime is used, allows remote attackers (from the client side) to
  trigger unnecessarily expensive server-side DHE modular-exponentiation calculations. The client
  may cause asymmetric resource consumption. The basic attack scenario is that the client must claim
  that it can only communicate with DHE, and the server must be configured to allow DHE and validate
  the order of the public key.");

  script_tag(name:"impact", value:"This vulnerability allows remote attackers (from the client side)
  to send arbitrary numbers that are actually not public keys, and trigger expensive server-side DHE
  modular-exponentiation calculations, also known as a D(HE)ater attack.

  There could be an increase in CPU usage in the affected component. For OpenSSH, users may observe
  issues such as a slowdown in SSH connections.");

  script_tag(name:"solution", value:"- DHE key exchange should be disabled if no other mitigation
  mechanism can be used and either elliptic-curve variant of Diffie-Hellman (ECDHE) or RSA key
  exchange is supported by the clients. The fact that RSA key exchange is not forward secret should
  be considered.

  - Limit the maximum number of concurrent connections in e.g. the configuration of the remote
  server. For Postfix this limit can be configured via 'smtpd_client_new_tls_session_rate_limit'
  option, for other products please refer to the manual of the product in question on configuration
  possibilities.");

  script_tag(name:"qod_type", value:"remote_banner_unreliable");
  script_tag(name:"solution_type", value:"Mitigation");

  exit(0);
}

include("ssl_funcs.inc");
include("host_details.inc");

cipherText = "'DHE' cipher suites";

if( ! port = tls_ssl_get_port() )
  exit( 0 );

if( ! sup_ssl = get_kb_item( "tls/supported/" + port ) )
  exit( 0 );

if( "SSLv3" >< sup_ssl ) {
  sslv3CipherList = get_kb_list( "ssl_tls/ciphers/sslv3/" + port + "/supported_ciphers" );

  if( ! isnull( sslv3CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    sslv3CipherList = sort( sslv3CipherList );

    foreach sslv3Cipher( sslv3CipherList ) {
      if( sslv3Cipher =~ "^TLS_DHE_.+" ) {
        sslv3Vuln = TRUE;
        sslv3tmpReport += sslv3Cipher + '\n';
      }
    }

    if( sslv3Vuln ) {
      report += cipherText +' accepted by this service via the SSLv3 protocol:\n\n' + sslv3tmpReport + '\n';
    }
  }
}

if( "TLSv1.0" >< sup_ssl ) {
  tlsv1_0CipherList = get_kb_list( "ssl_tls/ciphers/tlsv1/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_0CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_0CipherList = sort( tlsv1_0CipherList );

    foreach tlsv1_0Cipher( tlsv1_0CipherList ) {
      if( tlsv1_0Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_0Vuln = TRUE;
        tlsv1_0tmpReport += tlsv1_0Cipher + '\n';
      }
    }

    if( tlsv1_0Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.0 protocol:\n\n' + tlsv1_0tmpReport + '\n';
    }
  }
}

if( "TLSv1.1" >< sup_ssl ) {
  tlsv1_1CipherList = get_kb_list( "ssl_tls/ciphers/tlsv1_1/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_1CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_1CipherList = sort( tlsv1_1CipherList );

    foreach tlsv1_1Cipher( tlsv1_1CipherList ) {
      if( tlsv1_1Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_1Vuln = TRUE;
        tlsv1_1tmpReport += tlsv1_1Cipher + '\n';
      }
    }

    if( tlsv1_1Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.1 protocol:\n\n' + tlsv1_1tmpReport + '\n';
    }
  }
}

if( "TLSv1.2" >< sup_ssl ) {
  tlsv1_2CipherList = get_kb_list( "ssl_tls/ciphers/tlsv1_2/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_2CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_2CipherList = sort( tlsv1_2CipherList );

    foreach tlsv1_2Cipher( tlsv1_2CipherList ) {
      if( tlsv1_2Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_2Vuln = TRUE;
        tlsv1_2tmpReport += tlsv1_2Cipher + '\n';
      }
    }

    if( tlsv1_2Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.2 protocol:\n\n' + tlsv1_2tmpReport + '\n';
    }
  }
}

if( "TLSv1.3" >< sup_ssl ) {
  tlsv1_3CipherList = get_kb_list( "ssl_tls/ciphers/tlsv1_3/" + port + "/supported_ciphers" );

  if( ! isnull( tlsv1_3CipherList ) ) {

    # Sort to not report changes on delta reports if just the order is different
    tlsv1_3CipherList = sort( tlsv1_3CipherList );

    foreach tlsv1_3Cipher( tlsv1_3CipherList ) {
      if( tlsv1_3Cipher =~ "^TLS_DHE_.+" ) {
        tlsv1_3Vuln = TRUE;
        tlsv1_3tmpReport += tlsv1_3Cipher + '\n';
      }
    }

    if( tlsv1_3Vuln ) {
      report += cipherText + ' accepted by this service via the TLSv1.3 protocol:\n\n' + tlsv1_3tmpReport + '\n';
    }
  }
}

if( report ) {

  # nb:
  # - Store the reference from this one to gb_ssl_tls_ciphers_report.nasl to show a cross-reference within the
  #   reports
  # - We don't want to use get_app_* functions as we're only interested in the cross-reference here
  register_host_detail( name:"detected_by", value:"1.3.6.1.4.1.25623.1.0.802067" ); # gb_ssl_tls_ciphers_report.nasl
  register_host_detail( name:"detected_at", value:port + "/tcp" );

  security_message( port:port, data:report );
  exit( 0 );
}

exit( 99 );
